#+TITLE:     notes.org
#+AUTHOR:    Michael Buksas
#+EMAIL:     mb1@buksas.net
#+DATE:      2011-02-19 Sat

* General notes:

Treat a particle that might be dead as a Maybe Particle? Or make
Alive/Dead into a monad.

The only times I need the final complete state of the particle in an
Event are when it dies. Treat these differently then Events. Fates?

The life and times of a particle:

  InFlight -> InFlight
  InFlight -> Dead

I need an event which takes me to the final destination. Then, I need
to terminate the unfold.

 step :: Stuff -> Particle -> Maybe (Event, Particle)

Event should be called Step.

 step :: Stuff -> Particle -> Maybe (Step, Particle)

So, while stepping, I decide the particle is done.

  InFlight --> Dead.

Here, Step is something like:

  Step = { motion :: Motion , limiter :: Limiter }

The returned particle from step is Dead.

The next step operation on the dead particle just returns Nothing.

  step :: _ Dead = Nothing

So, I get the final Step; Then I stop the unfold.

Put Events and Fates in the same data structure:

  Step = (Motion, Event | Fate p)

* Deciding what to do to a particle

On each step:

1. Compute distances to scattering, absorption, escape, etc.
2. Select the shortest distance
3. Streaming the particle this distance.
4. Apply a limiting operation to the particle, based on the result of 2:
   1. Another function to transform the particle. E.g. scatter.
   2. Construct and return the correct Limiter.

Need a way of labeling limiters aside from the constructors in the Limiter type.

Something like a pre-event and actual event. Or I could compute the
_outcome_ of each event as well, and so the Event data would contain
everything it needed. E.g. momentum deposition.

Pair each event when computed with it's distance. Then choose the
winning (shortest) distance and put it's event on the list.

There's a pair of functions here for each limiter:

  distance_to_limiter :: Environment -> Particle -> Distance
  apply_limiter       :: Environment -> Particle -> (Limiter, Particle)

What is the environment? Opacity, at least. Make it a parameter?

Is there a environment for stepping? If I want scatter to be an event
which applies to random particle, then I need the opacity to compute the distance.

I need opacity to compute distance to scatter, but not to apply
it. This is mixing up my seperation between RandomParticle and MeshedParticle.


| Event         | To Compute Distance | To Apply      | Information Needed in Event |
|---------------+---------------------+---------------+-----------------------------|
| Scattering    | Opacity             | Random Sample | Momentum                    |
| Face crossing | Mesh and Cell       |               | Face/Cell index             |
| Time step end | Time Step duration  |               | Final Particle              |
| Absorption    | Energy Weight       |               | Final Particle              |

So what are the right levels to compose algorithms?

| Simulates                | Environment | Particle Data             | Events                 |
|--------------------------+-------------+---------------------------+------------------------|
| Motion in Space          | Space       | Position, Direction, etc. | None?                  |
| Motion in Time           | Time Step   | Clock                     | Termination            |
| Scattering, Absorption   | Opacity     | RandomState               | Scattering, Absorption |
| Motion in Discrete Space | Mesh        | Cell Index                | Face crossing, Esacpe. |


What would I like the resulting code to look like?


* Environments and Local Properties

Assume attributes are constant in space. Then the space properties are given by:

  environment :: Environment -> Particle -> Properties.

  data Properties = { localOpacity :: Opacity,  localTemperature :: Temperature , etc... }

Properties could even contain geometry of the current cell for distance calculations.

  data Properties = { localOpacity :: Opacity, localCell :: Cell, etc... }


* Local contributions and the Global Tally

What about the tally?

  data Tally = { Momentum :: MeshVector, Energy :: MeshDouble }  <- Depends on the index range.

How about parts of the tally?

  data TallyContrib = { Momentum :: Vector, Energy :: Double, Index :: MeshIndex }  <- Depends on the mesh index


** Connecting events to the Tally:

  contribution :: Event -> TallyContrib


** Creating the global tally

   addTally :: Tally -> TallyContrib -> Tally


   tally :: GlobalTally
   computeTally :: [TallyContrib] -> Tally
   computeTally initTally contribs = foldl addTally initTally contribs

* Unfolding versus iterating

** Unfolding

When all steps can succeed:

  step :: Particle -> (Event, Particle)

I can't unfold this because I need Maybe (Event, Particle).

I can have a test on events for final ones:

  is_final :: Event -> Bool

but unfold works by feeding the resulting particle back into step, so
I can't apply is_final and decide to return Nothing.

This is why I need a dead state for the particle.

Using Maybe:

  ParticleM = Maybe Particle

  step :: Particle -> (Event, Particle)

  stepM :: Maybe Particle -> Maybe (Event, Particle)
  stepM Just p = Just $ step p
  stepM Nothing = Nothing

  stepM = liftM step  ??


Using a status type:





** Iterating

  (Event, Particle) -> (Event, Particle)

can be iterated, provided I add an inital event, like "Born"
